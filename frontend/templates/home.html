<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SpotLocator - Smart Parking Finder</title>

  <!-- Google Fonts & Material Icons -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    /* Header Styles */
    .header {
      background: linear-gradient(135deg, #2196F3 0%, #21CBF3 100%);
      color: white;
      padding: 20px 0;
      box-shadow: 0 8px 32px rgba(33, 150, 243, 0.3);
      position: relative;
      overflow: hidden;
    }

    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="parking" patternUnits="userSpaceOnUse" width="20" height="20"><circle cx="10" cy="10" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23parking)"/></svg>');
      opacity: 0.3;
    }

    .header-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      z-index: 2;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .logo-icon {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .logo-icon .material-icons {
      font-size: 32px;
      color: white;
    }

    .logo-text h1 {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .logo-text p {
      font-size: 16px;
      opacity: 0.9;
      font-weight: 300;
    }

    .header-stats {
      display: flex;
      gap: 30px;
      align-items: center;
    }

    .stat-item {
      text-align: center;
      background: rgba(255, 255, 255, 0.15);
      padding: 12px 20px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }

    .stat-item:hover {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.25);
    }

    .stat-number {
      font-size: 24px;
      font-weight: 700;
      display: block;
    }

    .stat-label {
      font-size: 12px;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Sidebar styles - Enhanced */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 70px;
      height: 100%;
      background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 120px;
      box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
      z-index: 999;
      backdrop-filter: blur(10px);
    }

    .sidebar a {
      text-decoration: none;
      margin: 15px 0;
      padding: 15px;
      border-radius: 12px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .sidebar a::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .sidebar a:hover::before {
      opacity: 1;
    }

    .sidebar a:hover {
      transform: translateX(5px);
    }

    .sidebar .material-icons {
      color: rgba(255, 255, 255, 0.8);
      font-size: 28px;
      cursor: pointer;
      position: relative;
      z-index: 1;
    }

    .sidebar a:hover .material-icons {
      color: white;
    }

    /* Main content area */
    .main {
      margin-left: 70px;
      padding: 30px;
      padding-top: 150px;
      min-height: 100vh;
    }

    /* Search container - Enhanced */
    .search-section {
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
      margin-bottom: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .search-header {
      text-align: center;
      margin-bottom: 25px;
    }

    .search-header h2 {
      color: #2c3e50;
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .search-header p {
      color: #7f8c8d;
      font-size: 16px;
    }

    .search-container {
      position: relative;
      display: flex;
      justify-content: center;
      margin: 0 auto;
      width: 100%;
      max-width: 600px;
    }

    /* Search bar - Enhanced */
    .search-bar {
      display: flex;
      align-items: center;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      padding: 15px 20px;
      border-radius: 50px;
      width: 100%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border: 2px solid transparent;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .search-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #667eea, #764ba2);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 50px;
    }

    .search-bar:focus-within {
      border-color: #2196F3;
      box-shadow: 0 15px 40px rgba(33, 150, 243, 0.2);
    }

    .search-bar:focus-within::before {
      opacity: 0.1;
    }

    .search-bar input {
      width: 100%;
      padding: 8px 15px;
      border: none;
      background: transparent;
      font-size: 18px;
      outline: none;
      color: #2c3e50;
      font-weight: 500;
      position: relative;
      z-index: 2;
    }

    .search-bar input::placeholder {
      color: #95a5a6;
      font-weight: 400;
    }

    .search-bar .search-icon {
      color: #2196F3;
      font-size: 24px;
      margin-left: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      z-index: 2;
    }

    .search-bar .search-icon:hover {
      color: #1976D2;
      transform: scale(1.1);
    }

    /* Suggestions dropdown - Enhanced */
    .suggestions-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      max-height: 400px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      margin-top: 8px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .suggestion-item {
      padding: 16px 20px;
      cursor: pointer;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      display: flex;
      align-items: center;
      gap: 15px;
      transition: all 0.2s ease;
    }

    .suggestion-item:hover,
    .suggestion-item.highlighted {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      transform: translateX(5px);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-icon {
      width: 24px;
      height: 24px;
      color: #2196F3;
      flex-shrink: 0;
    }

    .suggestion-content {
      flex: 1;
    }

    .suggestion-title {
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 4px;
      font-size: 16px;
    }

    .suggestion-description {
      font-size: 14px;
      color: #7f8c8d;
    }

    .suggestion-type {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .suggestion-type.street {
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      color: #1976d2;
    }

    .suggestion-type.landmark {
      background: linear-gradient(135deg, #f3e5f5, #e1bee7);
      color: #7b1fa2;
    }

    /* Filters section - Enhanced */
    .filters {
      background: white;
      margin-bottom: 30px;
      padding: 25px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .filters-header {
      margin-bottom: 20px;
    }

    .filters-header h3 {
      color: #2c3e50;
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .filters-header p {
      color: #7f8c8d;
      font-size: 14px;
    }

    .filter-controls {
      display: flex;
      align-items: center;
      gap: 30px;
      flex-wrap: wrap;
    }

    .filter-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .filter-group label {
      font-weight: 600;
      color: #2c3e50;
      font-size: 16px;
    }

    .filter-group select {
      padding: 10px 15px;
      border: 2px solid #e9ecef;
      border-radius: 12px;
      background: white;
      font-size: 14px;
      font-weight: 500;
      color: #2c3e50;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .filter-group select:focus {
      outline: none;
      border-color: #2196F3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }

    /* Content layout */
    .content-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    .map-section,
    .results-section {
      width: 100%;
    }

    /* Map container - Enhanced */
    .map-container {
      height: 500px;
      width: 100%;
      border-radius: 20px;
      background: white;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      display: none;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    .map-container.show { display: block; }

    .map-controls {
      background: white;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
      display: none;
      width: 100%;
      margin: 20px 0;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    .map-controls.show { display: block; }

    .map-legend {
      display: flex;
      gap: 25px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      font-weight: 500;
      color: #2c3e50;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    /* Summary section - Enhanced */
    .parking-summary {
      background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
      margin: 20px 0;
      padding: 25px;
      border-radius: 16px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      color: #155724;
      box-shadow: 0 8px 32px rgba(21, 87, 36, 0.1);
      border: 1px solid rgba(21, 87, 36, 0.1);
    }

    .out-of-bounds-message {
      background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      color: #c62828;
      margin: 20px 0;
      padding: 25px;
      border-radius: 16px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(198, 40, 40, 0.1);
      border: 1px solid rgba(198, 40, 40, 0.1);
    }

    .error-message {
      background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      color: #c62828;
      margin: 20px 0;
      padding: 25px;
      border-radius: 16px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(198, 40, 40, 0.1);
      border: 1px solid rgba(198, 40, 40, 0.1);
    }

    /* Parking card styles - Enhanced */
    .parking-card {
      background: white;
      padding: 25px;
      margin: 16px 0;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
      border: 1px solid rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }

    .parking-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.02), rgba(33, 203, 243, 0.02));
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .parking-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    }

    .parking-card:hover::before {
      opacity: 1;
    }

    .info-group {
      display: flex;
      flex-direction: column;
      flex: 1;
      position: relative;
      z-index: 2;
    }

    .info-group strong {
      margin-bottom: 8px;
      font-size: 18px;
      color: #2c3e50;
      font-weight: 600;
    }

    .info-group span {
      margin-bottom: 4px;
      color: #5a6c7d;
      font-size: 14px;
      font-weight: 500;
    }

    .info-group .distance-info {
      color: #7f8c8d;
      font-size: 14px;
      margin-top: 8px;
    }

    .status-group {
      display: flex;
      align-items: center;
      gap: 15px;
      position: relative;
      z-index: 2;
    }

    .status-btn {
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 25px;
      font-size: 14px;
      font-weight: 600;
      min-width: 100px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    .status-btn.available {
      background: linear-gradient(135deg, #4caf50, #45a049);
    }
    
    .status-btn.limited {
      background: linear-gradient(135deg, #ff9800, #f57c00);
    }
    
    .status-btn.occupied {
      background: linear-gradient(135deg, #f44336, #d32f2f);
    }

    .status-btn.unknown {
      background: linear-gradient(135deg, #9e9e9e, #757575);
    }

    .status-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .navigate-icon {
      color: #7f8c8d;
      cursor: pointer;
      transition: all 0.3s ease;
      padding: 10px;
      border-radius: 50%;
      background: rgba(127, 140, 141, 0.1);
    }
    
    .navigate-icon:hover {
      color: #2196F3;
      background: rgba(33, 150, 243, 0.1);
      transform: scale(1.2);
    }

    .no-parking-message, .loading-message {
      padding: 60px 40px;
      text-align: center;
      color: #7f8c8d;
      font-size: 20px;
      font-weight: 500;
      background: white;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
    }

    /* Loading States */
    .suggestions-loading {
      padding: 16px 20px;
      text-align: center;
      color: #7f8c8d;
      font-size: 16px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        gap: 20px;
        text-align: center;
      }

      .header-stats {
        gap: 20px;
      }

      .stat-item {
        padding: 10px 15px;
      }

      .main {
        margin-left: 0;
        padding: 20px;
        padding-top: 20px;
      }
      
      .sidebar {
        display: none;
      }
      
      .search-section {
        padding: 25px 20px;
      }

      .search-header h2 {
        font-size: 22px;
      }

      .search-bar {
        padding: 12px 18px;
      }

      .search-bar input {
        font-size: 16px;
      }

      .filter-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 15px;
      }

      .filter-group {
        justify-content: space-between;
      }

      .map-container {
        height: 350px;
        border-radius: 16px;
      }

      .parking-card {
        flex-direction: column;
        align-items: stretch;
        gap: 20px;
        padding: 20px;
      }

      .status-group {
        justify-content: space-between;
      }
    }

    /* Custom Scrollbar */
    .suggestions-dropdown::-webkit-scrollbar {
      width: 6px;
    }

    .suggestions-dropdown::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }

    .suggestions-dropdown::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #2196F3, #21CBF3);
      border-radius: 10px;
    }

    /* Animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .parking-card {
      animation: fadeInUp 0.5s ease forwards;
    }

    .parking-card:nth-child(even) {
      animation-delay: 0.1s;
    }

    .parking-card:nth-child(odd) {
      animation-delay: 0.05s;
    }
  </style>

  <!-- Leaflet JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    const searchInput = document.querySelector('.search-bar input');
    const searchIcon = document.querySelector('.search-icon');
    const parkingContainer = document.querySelector('.parking-cards-container');
    const distanceFilter = document.getElementById('distanceFilter');
    const sortFilter = document.getElementById('sortFilter');
    const mapContainer = document.querySelector('.map-container');
    const mapControls = document.querySelector('.map-controls');

    let currentParkingData = [];
    let currentSearchLocation = '';
    let suggestions = [];
    let selectedSuggestionIndex = -1;
    let suggestionsTimeout;
    let map = null;
    let markersGroup = null;
    let searchLocationMarker = null;

    // Create suggestions dropdown
    const suggestionsDropdown = document.createElement('div');
    suggestionsDropdown.className = 'suggestions-dropdown';
    document.querySelector('.search-container').appendChild(suggestionsDropdown);

    // Initialize map
    function initializeMap(lat, lng) {
      if (map) {
        map.remove();
      }
      
      // Show map container and controls
      mapContainer.classList.add('show');
      mapControls.classList.add('show');
      
      // Create map centered on search location
      map = L.map('map').setView([lat, lng], 15);
      
      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '¬© OpenStreetMap contributors'
      }).addTo(map);
      
      // Create marker groups
      markersGroup = L.layerGroup().addTo(map);
      
      // Add search location marker
      searchLocationMarker = L.marker([lat, lng], {
        icon: L.divIcon({
          className: 'search-location-marker',
          html: '<div style="background: #2196F3; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
          iconSize: [26, 26],
          iconAnchor: [13, 13]
        })
      }).addTo(map);
      
      searchLocationMarker.bindPopup(`<b>Search Location</b><br>${currentSearchLocation}`);
    }

    // Update map markers based on filtered data
    function updateMapMarkers(parkingData) {
      if (!map || !markersGroup) return;

      // Clear existing markers
      markersGroup.clearLayers();

      // Filter data based on current filters
      const filteredData = filterAndSortData(parkingData);

      filteredData.forEach(spot => {
        // Segment-aware display: green if any bay in this segment is free
        const hasAnyFree = spot.segment_counts && Number(spot.segment_counts.available) > 0;
        const displayStatus = hasAnyFree ? 'Available' : 'Occupied';

        // Use segment display status for marker color/icon
        const color = getStatusColor(displayStatus);
        const icon = getStatusIcon(displayStatus);

        // Create the marker (segment-colored bubble)
        const marker = L.marker([spot.lat, spot.lng], {
          icon: L.divIcon({
            className: 'parking-marker',
            html: `<div style="
              background:${color};
              color:#fff;
              width:24px;height:24px;border-radius:50%;
              border:2px solid #fff;
              box-shadow:0 2px 4px rgba(0,0,0,.3);
              display:flex;align-items:center;justify-content:center;
              font-size:12px;font-weight:bold;">${icon}</div>`,
            iconSize: [28, 28],
            iconAnchor: [14, 14]
          })
        });

        // Safe distance + updated text
        const distanceText = (spot.distance !== '?' && !isNaN(parseFloat(spot.distance)))
          ? `${parseFloat(spot.distance).toFixed(2)} km`
          : 'Unknown';
        const updatedText = spot.last_updated
          ? new Date(spot.last_updated).toLocaleTimeString()
          : new Date().toLocaleTimeString();

        // Popup content
        const popupContent = `
          <div class="custom-popup">
            <div class="popup-content">
              <div class="popup-title">${spot.address}</div>
              <div class="popup-status" style="background-color:${color};">Segment: ${displayStatus}</div>
              ${spot.segment_counts ? `
                <div class="popup-info">
                  Available: ${spot.segment_counts.available} of ${spot.segment_counts.total} bays
                </div>` : ``}
              <div class="popup-info">This bay (ID ${spot.kerbsideid}): ${spot.status}</div>
              <div class="popup-info">Distance: ${distanceText}</div>
              <div class="popup-info">Updated: ${updatedText}</div>
              <button class="popup-navigate" onclick="openNavigation(${spot.lat}, ${spot.lng}, '${spot.address.replace(/'/g, "\\'")}')">Navigate</button>
            </div>
          </div>
        `;

        marker.bindPopup(popupContent);
        markersGroup.addLayer(marker);
      });

      // Auto-fit map bounds if we have markers
      if (filteredData.length > 0 && searchLocationMarker) {
        const group = L.featureGroup([markersGroup, searchLocationMarker]);
        map.fitBounds(group.getBounds().pad(0.1));
      }
    }

    // Get status color for map markers
    function getStatusColor(status) {
      const colors = {
        'Available': '#4CAF50',
        'Limited': '#FF9800', 
        'Occupied': '#F44336',
        'Unknown': '#9E9E9E'
      };
      return colors[status] || '#9E9E9E';
    }

    // Get status icon for map markers
    function getStatusIcon(status) {
      const icons = {
        'Available': '‚úì',
        'Limited': '!',
        'Occupied': '‚úó', 
        'Unknown': '?'
      };
      return icons[status] || '?';
    }

    // Normalize status from backend to frontend
    function normalizeStatus(statusDescription) {
      if (!statusDescription) return 'unknown';
      const status = String(statusDescription).toLowerCase();

      if (status.includes('available') || status.includes('unoccupied') || status.includes('free') || status.includes('vacant') || status.includes('open')) {
        return 'available';
      }
      // IMPORTANT: 'present' means car detected ‚Üí occupied
      if (status.includes('occupied') || status.includes('present') || status.includes('taken') || status.includes('full') || status.includes('busy') || status.includes('in use')) {
        return 'occupied';
      }
      if (
        status.includes('limited') || status.includes('partial') || status.includes('restricted') ||
        status.includes('loading') || status.includes('short stay') || status.includes('permit') ||
        status.includes('disabled') || status.includes('clearway')
      ) {
        return 'limited';
      }
      if (status.includes('unknown') || status.includes('no data') || status.includes('offline') || status.includes('error') || status.includes("haven't published")) {
        return 'unknown';
      }
      return 'unknown';
    }

    function getDisplayStatus(spot) {
      // Use segment counts first (same rule as map)
      if (spot.segment_counts && typeof spot.segment_counts.available === 'number') {
        return spot.segment_counts.available > 0 ? 'available' : 'occupied';
      }
      // Fallback to text status
      return normalizeStatus(spot.status);
    }

    // Get display text for status
    function getStatusText(normalizedStatus) {
      switch (normalizedStatus) {
        case 'available': return 'Available';
        case 'occupied': return 'Occupied';
        case 'limited': return 'Limited';
        default: return 'Unknown';
      }
    }

    // Get status priority for sorting (lower = higher priority)
    function getStatusPriority(normalizedStatus) {
      switch (normalizedStatus) {
        case 'available': return 1;
        case 'limited': return 2;
        case 'unknown': return 3;
        case 'occupied': return 4;
        default: return 5;
      }
    }

    // Filter and sort parking data
    function filterAndSortData(data) {
      let filtered = [...data];

      // distance filter
      const maxDistance = parseFloat(distanceFilter.value);
      if (maxDistance > 0) {
        filtered = filtered.filter(spot =>
          spot.distance === '?' || parseFloat(spot.distance) <= maxDistance
        );
      }

      // sorting
      const sortBy = sortFilter.value;
      filtered.sort((a, b) => {
        if (sortBy === 'availability') {
          const statusA = getDisplayStatus(a);
          const statusB = getDisplayStatus(b);
          const priorityA = getStatusPriority(statusA);
          const priorityB = getStatusPriority(statusB);

          if (priorityA !== priorityB) return priorityA - priorityB;
          if (a.distance !== '?' && b.distance !== '?') {
            return parseFloat(a.distance) - parseFloat(b.distance);
          }
          return 0;
        } else if (sortBy === 'distance') {
          if (a.distance === '?' && b.distance === '?') return 0;
          if (a.distance === '?') return 1;
          if (b.distance === '?') return -1;
          return parseFloat(a.distance) - parseFloat(b.distance);
        }
        return 0;
      });

      return filtered;
    }

    // Show loading message
    function showLoading() {
      const container = document.querySelector('.parking-cards-container');
      container.innerHTML = '<div class="loading-message">üîç Searching for parking spots...</div>';
    }

    // Show error message
    function showError(message) {
      const container = document.querySelector('.parking-cards-container');
      container.innerHTML = `<div class="error-message">‚ùå ${message}</div>`;
    }

    // Fetch location suggestions from backend
    async function fetchSuggestions(query) {
      if (!query || query.length < 2) {
        hideSuggestions();
        return;
      }

      try {
        showSuggestionsLoading();
        const response = await fetch(`/api/location-suggestions/?q=${encodeURIComponent(query)}`);
        if (!response.ok) throw new Error('Network response was not ok');
        
        const data = await response.json();
        suggestions = data.suggestions || [];
        displaySuggestions(suggestions);
      } catch (error) {
        console.error('Error fetching suggestions:', error);
        hideSuggestions();
      }
    }

    // Show loading in suggestions dropdown
    function showSuggestionsLoading() {
      suggestionsDropdown.innerHTML = '<div class="suggestions-loading">üîç Loading suggestions...</div>';
      suggestionsDropdown.style.display = 'block';
    }

    // Display suggestions in dropdown
    function displaySuggestions(suggestionsList) {
      if (!suggestionsList || suggestionsList.length === 0) {
        hideSuggestions();
        return;
      }

      let html = '';
      suggestionsList.forEach((suggestion, index) => {
        const iconName = suggestion.type === 'landmark' ? 'place' : 'location_on';
        html += `
          <div class="suggestion-item" data-index="${index}">
            <span class="material-icons suggestion-icon">${iconName}</span>
            <div class="suggestion-content">
              <div class="suggestion-title">${suggestion.text}</div>
              <div class="suggestion-description">${suggestion.description}</div>
            </div>
            <span class="suggestion-type ${suggestion.type}">${suggestion.type}</span>
          </div>
        `;
      });

      suggestionsDropdown.innerHTML = html;
      suggestionsDropdown.style.display = 'block';
      selectedSuggestionIndex = -1;

      // Add click handlers
      const suggestionItems = suggestionsDropdown.querySelectorAll('.suggestion-item');
      suggestionItems.forEach((item, index) => {
        item.addEventListener('click', () => selectSuggestion(index));
      });
    }

    // Hide suggestions dropdown
    function hideSuggestions() {
      suggestionsDropdown.style.display = 'none';
      selectedSuggestionIndex = -1;
    }

    // Select a suggestion
    function selectSuggestion(index) {
      if (index >= 0 && index < suggestions.length) {
        const suggestion = suggestions[index];
        searchInput.value = suggestion.text;
        hideSuggestions();
        
        // If suggestion has coordinates, use them directly
        if (suggestion.lat && suggestion.lng) {
          fetchNearbySpots(suggestion.lat, suggestion.lng, suggestion.text);
        } else {
          // Otherwise trigger normal search
          performSearch();
        }
      }
    }

    // Handle keyboard navigation in suggestions
    function handleSuggestionNavigation(e) {
      const suggestionItems = suggestionsDropdown.querySelectorAll('.suggestion-item');
      
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestionItems.length - 1);
        updateSuggestionHighlight();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
        updateSuggestionHighlight();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (selectedSuggestionIndex >= 0) {
          selectSuggestion(selectedSuggestionIndex);
        } else {
          hideSuggestions();
          performSearch();
        }
      } else if (e.key === 'Escape') {
        hideSuggestions();
      }
    }

    // Update visual highlighting of suggestions
    function updateSuggestionHighlight() {
      const suggestionItems = suggestionsDropdown.querySelectorAll('.suggestion-item');
      suggestionItems.forEach((item, index) => {
        item.classList.toggle('highlighted', index === selectedSuggestionIndex);
      });
    }

    // Live search using Django API
    async function performSearch() {
      const searchTerm = searchInput.value.trim();
      hideSuggestions();
      
      // Show loading immediately
      showLoading();

      if (searchTerm === '') {
        // Use current location
        if (!navigator.geolocation) {
          showError('Geolocation is not supported by your browser');
          return;
        }

        navigator.geolocation.getCurrentPosition(async (position) => {
          const userLat = position.coords.latitude;
          const userLng = position.coords.longitude;

          await fetchNearbySpots(userLat, userLng, 'Your current location');
        }, () => {
          showError('Unable to retrieve your location');
        });

      } else {
        // Convert text location to coordinates
        try {
          const geoResp = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchTerm + ', Melbourne, Australia')}`,
            {
              headers: {
                'User-Agent': 'SmartParkingFinder/1.0'
              }
            }
          );
          
          if (!geoResp.ok) {
            throw new Error(`Geocoding failed with status: ${geoResp.status}`);
          }
          
          const geoData = await geoResp.json();

          if (geoData.length === 0) {
            showError('Location not found. Please try a nearby landmark in Melbourne CBD.');
            return;
          }

          const userLat = parseFloat(geoData[0].lat);
          const userLng = parseFloat(geoData[0].lon);
          
          // This will clear the loading state and update cards/map
          await fetchNearbySpots(userLat, userLng, searchTerm);

        } catch (error) {
          console.error('Geocoding failed:', error);
          showError('Error finding the location. Please check your internet connection and try again.');
        }
      }
    }

    // Fetch nearby parking spots from API
    async function fetchNearbySpots(lat, lng, label) {
      try {
        console.log(`Fetching parking data for: ${label} (${lat}, ${lng})`);
        
        const response = await fetch(`/api/spots/nearby/?lat=${lat}&lng=${lng}&query=${encodeURIComponent(label)}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          }
        });

        console.log('Response status:', response.status);

        if (!response.ok) {
          const errorText = await response.text();
          console.error('API Error Response:', errorText);
          
          if (response.status === 404) {
            showError('Location not found. Please try a different location.');
          } else if (response.status >= 500) {
            showError('Server error. Please try again later.');
          } else {
            showError('Failed to retrieve parking data. Please try again.');
          }
          return;
        }

        const data = await response.json();
        console.log('API Response data:', data);

        // Check if location is outside CBD
        if (data.in_cbd === false || (data.total_count === 0 && data.message && data.message.includes('outside'))) {
          showOutOfBoundsMessage(label, data.message || 'This location is outside Melbourne CBD area');
          return;
        }

        // Set location and initialize map FIRST
        currentSearchLocation = label;
        initializeMap(lat, lng);

        // Update currentParkingData immediately
        if (data.success !== false && data.results && data.results.length > 0) {
          currentParkingData = data.results;
          console.log(`Updated currentParkingData with ${currentParkingData.length} spots`);
        } else {
          currentParkingData = [];
          console.log('No parking data found, setting empty array');
        }

        // CRITICAL: Update both cards and map immediately after getting data
        console.log('Calling updateParkingCards immediately...');
        updateParkingCards();
        
        console.log('Calling updateMapMarkers immediately...');
        updateMapMarkers(currentParkingData);

      } catch (error) {
        console.error('Error fetching nearby spots:', error);
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          showError('Network error. Please check your internet connection.');
        } else {
          showError('Failed to retrieve parking data. Please try again.');
        }
      }
    }

    // Show out of bounds message
    function showOutOfBoundsMessage(location, message) {
      const container = document.querySelector('.parking-cards-container');
      
      // Clear any existing summary or error messages
      const existingSummary = document.querySelector('.parking-summary');
      const existingError = document.querySelector('.out-of-bounds-message');
      const existingErrorMsg = document.querySelector('.error-message');
      if (existingSummary) existingSummary.remove();
      if (existingError) existingError.remove();
      if (existingErrorMsg) existingErrorMsg.remove();

      // Hide map and controls since location is out of bounds
      mapContainer.classList.remove('show');
      mapControls.classList.remove('show');

      const outOfBoundsDiv = document.createElement('div');
      outOfBoundsDiv.className = 'out-of-bounds-message';
      outOfBoundsDiv.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 15px;">
          <span style="font-size: 32px;">üö´</span>
          <span style="font-size: 20px; font-weight: bold;">Location Outside Melbourne CBD</span>
        </div>
        <div style="font-size: 18px; margin-bottom: 10px;">"${location}" is not within our coverage area</div>
        <div style="font-size: 16px; font-weight: normal; line-height: 1.5; opacity: 0.8;">
          SpotLocator provides parking data only for Melbourne CBD area.<br>
          Please search for locations like: Flinders Street Station, Collins Street, Bourke Street Mall, etc.
        </div>
      `;
      container.parentNode.insertBefore(outOfBoundsDiv, container);

      container.innerHTML = `
        <div class="no-parking-message">
          <div style="font-size: 24px; margin-bottom: 12px;">üÖøÔ∏è No Parking Data Available</div>
          <div>Try searching within Melbourne CBD for real-time parking information</div>
        </div>
      `;
    }

    // Render cards from live API data
    function updateParkingCards() {
      console.log('updateParkingCards called, currentParkingData length:', currentParkingData ? currentParkingData.length : 'undefined');

      const container = document.querySelector('.parking-cards-container');
      if (!container) {
        console.error('parking-cards-container not found!');
        return;
      }

      // Clear loading/error states immediately
      container.innerHTML = '';

      // Remove any existing summaries/messages
      const existingSummary = document.querySelector('.parking-summary');
      const existingError = document.querySelector('.out-of-bounds-message');
      const existingErrorMsg = document.querySelector('.error-message');
      if (existingSummary) existingSummary.remove();
      if (existingError) existingError.remove();
      if (existingErrorMsg) existingErrorMsg.remove();

      // Check if we have parking data
      if (!currentParkingData || currentParkingData.length === 0) {
        console.log('No parking data, showing no spots message');
        container.innerHTML = `
          <div class="no-parking-message">
            <div style="font-size: 24px; margin-bottom: 12px;">üÖøÔ∏è No Parking Spots Found</div>
            <div>No parking data available near ${currentSearchLocation || 'this location'}</div>
            <div style="font-size: 16px; color: #7f8c8d; margin-top: 12px;">Try searching a different location within Melbourne CBD</div>
          </div>
        `;
        return;
      }

      console.log('Processing parking data for cards...');

      // Apply current filters/sorting
      const filteredData = filterAndSortData(currentParkingData);
      console.log('Filtered data length:', filteredData.length);

      // Calculate summary statistics using segment logic
      const statusCounts = { available: 0, occupied: 0 };
      filteredData.forEach(parking => {
        const s = getDisplayStatus(parking);
        if (s === 'available') statusCounts.available++;
        else statusCounts.occupied++;
      });

      // Create summary section (two categories only)
      const summaryDiv = document.createElement('div');
      summaryDiv.className = 'parking-summary';
      summaryDiv.innerHTML = `
        <div style="font-size: 20px; margin-bottom: 12px;">üìç Found ${filteredData.length} parking spots near ${currentSearchLocation}</div>
        <div style="font-size: 16px; display: flex; justify-content: center; gap: 30px; flex-wrap: wrap;">
          <span style="color: #4caf50; display: flex; align-items: center; gap: 8px;">
            <span style="width: 12px; height: 12px; background: #4caf50; border-radius: 50%; display: inline-block;"></span>
            Available: ${statusCounts.available}
          </span>
          <span style="color: #f44336; display: flex; align-items: center; gap: 8px;">
            <span style="width: 12px; height: 12px; background: #f44336; border-radius: 50%; display: inline-block;"></span>
            Occupied: ${statusCounts.occupied}
          </span>
        </div>
      `;
      container.parentNode.insertBefore(summaryDiv, container);

      if (filteredData.length === 0) {
        container.innerHTML = `<div class="no-parking-message">üîç No parking spots found with current filters</div>`;
        return;
      }

      // Build cards
      filteredData.forEach(parking => {
        const card = document.createElement('div');
        card.className = 'parking-card';

        const displayStatus = getDisplayStatus(parking); // <- segment-based
        const statusText = displayStatus === 'available' ? 'Available' : 'Occupied';

        // counts text from segment_counts
        const availableBays = parking.segment_counts?.available;
        const totalBays = parking.segment_counts?.total;
        const availabilityLine =
          (typeof availableBays === 'number' && typeof totalBays === 'number')
            ? `Available: ${availableBays} of ${totalBays} bays`
            : 'Availability: Unknown';

        const now = new Date();
        const timeString = now.toLocaleTimeString();

        card.innerHTML = `
          <div class="info-group">
            <strong>üìç ${parking.address}</strong>
            <span>üÜî ID: ${parking.kerbsideid}</span>
            <span>üÖøÔ∏è ${availabilityLine}</span>
            <span class="distance-info">üìè Distance: ${parking.distance !== '?' ? parking.distance + ' km' : 'Unknown'}</span>
            <span style="font-size: 12px; color: #7f8c8d;">üïí Updated: ${timeString}</span>
          </div>
          <div class="status-group">
            <button class="status-btn ${displayStatus}">${statusText}</button>
            <span class="material-icons navigate-icon" data-lat="${parking.lat}" data-lng="${parking.lng}" data-address="${parking.address}" title="Navigate to parking">navigation</span>
          </div>
        `;

        container.appendChild(card);
      });

      // Rebind events (dblclick + nav icon)
      addCardEvents();
    }

    // Add event handlers for filter changes
    distanceFilter.addEventListener('change', () => {
      updateParkingCards();
      updateMapMarkers(currentParkingData);
    });
    
    sortFilter.addEventListener('change', () => {
      updateParkingCards();
      updateMapMarkers(currentParkingData);
    });

    // Hover + dblclick + nav icons
    function addCardEvents() {
      const parkingCards = document.querySelectorAll('.parking-card');

      parkingCards.forEach(function (card) {
        card.addEventListener('dblclick', function () {
          window.location.href = 'parking-detail.html';
        });

        card.style.cursor = 'pointer';
      });

      const navigateIcons = document.querySelectorAll('.navigate-icon');
      navigateIcons.forEach(function (icon) {
        icon.addEventListener('click', function (e) {
          e.stopPropagation();
          const lat = this.dataset.lat;
          const lng = this.dataset.lng;
          const address = this.dataset.address;
          openNavigation(lat, lng, address);
        });

        icon.style.cursor = 'pointer';
      });
    }

    // Make openNavigation global so popup buttons can use it
    window.openNavigation = function(lat, lng, address) {
      const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(address)}`;
      window.open(googleMapsUrl, '_blank');
    }

    // Search input event handlers
    searchInput.addEventListener('input', function(e) {
      clearTimeout(suggestionsTimeout);
      const query = e.target.value.trim();
      
      if (query.length >= 2) {
        suggestionsTimeout = setTimeout(() => fetchSuggestions(query), 300); // Debounce
      } else {
        hideSuggestions();
      }
    });

    searchInput.addEventListener('keydown', handleSuggestionNavigation);

    searchInput.addEventListener('blur', function() {
      // Delay hiding to allow click on suggestions
      setTimeout(hideSuggestions, 200);
    });

    searchInput.addEventListener('focus', function() {
      const query = this.value.trim();
      if (query.length >= 2) {
        fetchSuggestions(query);
      }
    });

    // Search icon and enter key events
    searchIcon.addEventListener('click', performSearch);
    searchInput.addEventListener('keypress', function (e) {
      if (e.key === 'Enter' && selectedSuggestionIndex === -1) {
        hideSuggestions();
        performSearch();
      }
    });

    // Hide suggestions when clicking outside
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.search-container')) {
        hideSuggestions();
      }
    });

    // Set up auto-refresh for real-time updates
    setInterval(() => {
      if (currentParkingData.length > 0) {
        // Only refresh if we have data (don't refresh empty states)
        updateParkingCards();
        updateMapMarkers(currentParkingData);
      }
    }, 30000); // Refresh every 30 seconds

    addCardEvents();
  });
  </script>

</head>

<body>
  <!-- Enhanced Header -->
  <header class="header">
    <div class="header-content">
      <div class="logo-section">
        <div class="logo-icon">
          <span class="material-icons">local_parking</span>
        </div>
        <div class="logo-text">
          <h1>SpotLocator</h1>
          <p>Smart Parking Solutions for Melbourne CBD</p>
        </div>
      </div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-number">24/7</span>
          <span class="stat-label">Real-time</span>
        </div>
        <div class="stat-item">
          <span class="stat-number">CBD</span>
          <span class="stat-label">Coverage</span>
        </div>
        <div class="stat-item">
          <span class="stat-number">Live</span>
          <span class="stat-label">Updates</span>
        </div>
      </div>
    </div>
  </header>

  <!-- Enhanced Sidebar -->
  <div class="sidebar">
    <!-- Traffic Insights -->
    <a href="/traffic/" title="Traffic Insights">
      <span class="material-icons">map</span>
    </a>
  </div>

  <!-- Main content -->
  <div class="main">
    <!-- Enhanced Search Section -->
    <div class="search-section">
      <div class="search-header">
        <h2>Find Your Perfect Parking Spot</h2>
        <p>Enter a location in Melbourne CBD to discover nearby parking availability</p>
      </div>
      
      <div class="search-container">
        <div class="search-bar">
          <input type="text" placeholder="üîç Search places in Melbourne CBD..." />
          <span class="material-icons search-icon">search</span>
        </div>
        <!-- Suggestions dropdown will be added here by JavaScript -->
      </div>
    </div>

    <!-- Enhanced Filters -->
    <div class="filters">
      <div class="filters-header">
        <h3>üéØ Refine Your Search</h3>
        <p>Customize your parking search with distance and sorting preferences</p>
      </div>
      
      <div class="filter-controls">
        <div class="filter-group">
          <label for="distanceFilter">üìè Distance:</label>
          <select id="distanceFilter">
            <option value="2">Within 2 km</option>
            <option value="1">Within 1 km</option>
            <option value="0.5">Within 0.5 km</option>
          </select>
        </div>
        
        <div class="filter-group">
          <label for="sortFilter">üîÑ Sort by:</label>
          <select id="sortFilter">
            <option value="availability">Availability (Available first)</option>
            <option value="distance">Distance (Nearest first)</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Enhanced Map controls and legend -->
    <div class="map-controls">
      <div class="map-legend">
        <div class="legend-item">
          <span class="legend-color" style="background-color: #4CAF50;"></span>
          <span>Available Spots</span>
        </div>
       
        <div class="legend-item">
          <span class="legend-color" style="background-color: #F44336;"></span>
          <span>Occupied Spots</span>
        </div>
       
        <div class="legend-item">
          <span class="legend-color" style="background-color: #2196F3;"></span>
          <span>Your Search Location</span>
        </div>
      </div>
    </div>

    <!-- Content layout with map and results -->
    <div class="content-layout">
      <!-- Map section -->
      <div class="map-section">
        <div id="map" class="map-container"></div>
      </div>

      <!-- Results section -->
      <div class="results-section">
        <div class="parking-cards-container"></div>
      </div>
    </div>

  </div>
</body>
</html>